


#include "pch.h"

#include "..\Common\DirectXHelper.h"
#include "gv_Scene3D.h"
#include "MoTran.h"


#pragma comment(lib, "DirectXTK")





#define GHV_OPTION_CHIRALITY_SINISTRAL          0x0001
#define GHV_OPTION_CHIRALITY_DEXTRAL            0x0002

#define GHV_OPTION_COORD_CHIRALITY      GHV_OPTION_CHIRALITY_SINISTRAL


using namespace KG;
using namespace DirectX;
using namespace Windows::Foundation;




float KG::Hvy3DScene::g_S2SphereRadius = 1.01f;





Hvy3DScene::Hvy3DScene(
    const std::shared_ptr<DX::DeviceResources>& deviceResources
) :
	m_loadingComplete(false),
	m_degreesPerSecond(45),
	m_indexCount(0),
    e_option_wireframe(true), 
    e_option_rotate_world(true), 
	m_deviceResources(deviceResources)
{
	CreateDeviceDependentResources();
	CreateWindowSizeDependentResources();

    m_keyboard = std::make_unique<DirectX::Keyboard>();
    m_mouse = std::make_unique<DirectX::Mouse>();

    Windows::UI::Core::CoreWindow  ^better_core_win 
        = Windows::UI::Core::CoreWindow::GetForCurrentThread();

    m_keyboard->SetWindow(better_core_win);
    m_mouse->SetWindow(better_core_win);
}





// Initializes view parameters when the window size changes.
void Hvy3DScene::CreateWindowSizeDependentResources()
{
	Size outputSize = m_deviceResources->GetOutputSize();
	float aspectRatio = outputSize.Width / outputSize.Height;
	float fovAngleY = 70.0f * XM_PI / 180.0f;

	// This is a simple example of change that can be made when the app is in
	// portrait or snapped view.
	if (aspectRatio < 1.0f)
	{
		fovAngleY *= 2.0f;
	}

	// Note that the OrientationTransform3D matrix is post-multiplied here
	// in order to correctly orient the scene to match the display orientation.
	// This post-multiplication step is required for any draw calls that are
	// made to the swap chain render target. For draw calls to other targets,
	// this transform should not be applied.


#if ((GHV_OPTION_COORD_CHIRALITY) ==  (GHV_OPTION_CHIRALITY_DEXTRAL))
	//      auto-generated by MSVC 2017 template: 
    //          This app makes use of a 
    //          right-handed coordinate system 
    //          using row-major matrices.

	XMMATRIX perspectiveMatrix = XMMatrixPerspectiveFovRH(
		fovAngleY, aspectRatio, 0.01f, 100.0f );
#else
    //  ghv : my geometry data is left-handed:
	XMMATRIX perspectiveMatrix = XMMatrixPerspectiveFovLH(
		fovAngleY, aspectRatio, 0.01f, 100.0f );
#endif



	XMFLOAT4X4 orientation = m_deviceResources->GetOrientationTransform3D();

	XMMATRIX orientationMatrix = XMLoadFloat4x4(&orientation);

	XMStoreFloat4x4(
		&m_constantBufferData.projection,
		XMMatrixTranspose(perspectiveMatrix * orientationMatrix)
		);


#if ((GHV_OPTION_COORD_CHIRALITY) ==  (GHV_OPTION_CHIRALITY_DEXTRAL))
	//      auto-generated by MSVC 2017 template: 
    //          This app makes use of a 
    //          right-handed coordinate system 
    //          using row-major matrices.
    static const XMVECTORF32 eye = { 0.0f, 0.7f, 1.5f, 0.0f };
	static const XMVECTORF32 at = { 0.0f, -0.1f, 0.0f, 0.0f };
	static const XMVECTORF32 up = { 0.0f, 1.0f, 0.0f, 0.0f };
	XMStoreFloat4x4(&m_constantBufferData.view, XMMatrixTranspose(XMMatrixLookAtRH(eye, at, up)));

#else

    //  ghv : my geometry data is left-handed:
    static const XMVECTORF32 eye = { 0.0f, 0.f, 1.5f, 0.0f };
	static const XMVECTORF32 at = { 0.0f,  0.f, 0.0f, 0.0f };
	static const XMVECTORF32 up = { 0.0f, 1.0f, 0.0f, 0.0f };
	XMStoreFloat4x4(&m_constantBufferData.view, XMMatrixTranspose(XMMatrixLookAtLH(eye, at, up)));

#endif
}












void Hvy3DScene::Update(DX::StepTimer const& timer)
{
    static double                   g0_total_sec_stop = 0.0;
    static double                   g0_total_sec_resume = 0.0;
    static double                   g0_eff_total_seconds = 0.0;
    DirectX::Keyboard::State           kb = m_keyboard->GetState();

    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    if (kb.O)
    { //   A request to resume the rotation: 
        if (!e_option_rotate_world)
        {
            g0_total_sec_resume = timer.GetTotalSeconds();

            e_option_rotate_world = true;
        }
    }  //  Closes "O"; 


    if (kb.K)
    { //    Request to stop the rotation. 
        if (e_option_rotate_world)
        {
            g0_total_sec_stop = g0_eff_total_seconds;

            e_option_rotate_world = false;
        }
    }  //  Closes "K"; 

    // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    if (kb.F3)
    {       //   A request to show wireframe: 
        if (e_option_wireframe == false)
        {
            e_option_wireframe = true;
        }
    }  //  Closes "F3"; 

    if (kb.F4)
    {       //   A request to de-activate wireframe and return to "solid" rendering: 
        if (e_option_wireframe == true)
        {
            e_option_wireframe = false;
        }
    }  //  Closes "F4"; 

    // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    double total_sec = 0.f;
    if (e_option_rotate_world)
    {
        total_sec = timer.GetTotalSeconds() - (g0_total_sec_resume - g0_total_sec_stop);  // perfect!!!
        g0_eff_total_seconds = total_sec;
    }
    else
    {
        total_sec = g0_total_sec_stop;
    }
	gv_rotate_cloud(total_sec);

    // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    static uint16_t     delay_idx = 0;
    uint16_t const      delay_speed = 12;   //  or e.g. 48; 
    (delay_idx + 1) > UINT16_MAX ? delay_idx = 0 : delay_idx++;
    uint32_t u_instance_idx = 0;
    if (delay_idx % delay_speed == 0)
    {
        u_instance_idx = (1 + m_constantBufferData.animator_count.x) % m_instanceCount;
        m_constantBufferData.animator_count = XMUINT4(u_instance_idx, 0, 0, 0);
    }
}
//  Closes Hvy3DScene::Update(); 






void Hvy3DScene::gv_rotate_cloud(double p_total_seconds)
{
    float radiansPerSecond = XMConvertToRadians(m_degreesPerSecond);
    double totalRotation = p_total_seconds * radiansPerSecond;
    float the_angle = static_cast<float>(fmod(totalRotation, XM_2PI));

    //      World Transform:
    // scale the entire world and all the instanced models contained therein: 

	XMMATRIX xmm_rotate = XMMatrixRotationY(-1.f * the_angle);

    float s = 4.8f;   // GOLD : s = 4.8f is better than 3.8f for McMull Kleinian; 

#ifdef GHV_OPTION_SPHERICAL_RENDER

    s = 5.5f; 
    XMMATRIX xmm_scaling = XMMatrixScaling(s, s, s);

#else

    s = 0.6f;
    XMMATRIX xmm_scaling = XMMatrixScaling(s, s, s);

#endif



    XMMATRIX xmm_translate = XMMatrixTranslation(0.f, 0.f, -9.f); 

    XMMATRIX xmm_world_transform = xmm_rotate * xmm_scaling * xmm_translate;

	XMStoreFloat4x4(
        &m_constantBufferData.model, 
        XMMatrixTranspose(
            xmm_world_transform
        )
    );
}
//  Closes Hvy3DScene::gv_rotate_cloud(); 






void Hvy3DScene::Render()
{
	// Loading is asynchronous. Only draw geometry after it's loaded.
	if (!m_loadingComplete)
	{
		return;
	}

	auto context = m_deviceResources->GetD3DDeviceContext();

	context->UpdateSubresource1(
		m_constantBuffer.Get(), 0, NULL, &m_constantBufferData, 0, 0, 0 );

    UINT                     strides[2];
    UINT                     offsets[2];
    ID3D11Buffer            *bufferPointers[2];
    
    strides[0] = sizeof(VHG_Vertex_PosTex);
    strides[1] = sizeof(VHG_Instance);
    offsets[0] = 0;
    offsets[1] = 0;
    bufferPointers[0] = m_vertexBuffer.Get();   
    bufferPointers[1] = m_instanceBuffer.Get();  
 
    context->IASetVertexBuffers(0, 2, bufferPointers, strides, offsets);
    // Each index is one 16-bit unsigned integer (short).
	context->IASetIndexBuffer( m_indexBuffer.Get(), DXGI_FORMAT_R16_UINT, 0 );


#ifdef GHV_OPTION_MESH_POINT
	context->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_POINTLIST); 

#else
	context->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
#endif

	context->IASetInputLayout(m_inputLayout.Get());

	context->VSSetShader( m_vertexShader.Get(), nullptr, 0 );
	context->VSSetConstantBuffers1( 0, 1, m_constantBuffer.GetAddressOf(), nullptr, nullptr );

	context->PSSetShader( m_pixelShader.Get(), nullptr, 0 );
    context->PSSetShaderResources(0, 1, e_texture_srv_1.GetAddressOf());
    context->PSSetSamplers(0, 1, e_texture_sampler_state.GetAddressOf());

    context->DrawIndexedInstanced(
        m_indexCount,
        m_instanceCount,
        0,  //   start index location is zero; 
        0,  //   base vertex location is zero; 
        0   //   start instance location is zero; 
    );
}
//  Closes Hvy3DScene::Render();  










uint32_t Hvy3DScene::gv_MeshHyperboloid(std::vector<VHG_Instance>    *p_vect_Instances)
{
    VHG_Instance            current_instance;

    UINT limit_theta = 64;  //  or use 64;  
    int limit_y_axis = 64; 

    //  show both sheets of hyperboloid : float y_min = -2.f;

    // float y_min = 0.21f;  // show only the upper sheet of the hyperboloid;

    // float y_min = 0.1f;  // show only the upper sheet of the hyperboloid;

    // float y_min = 0.05f;  // show only the upper sheet of the hyperboloid;

    float y_min = 1.02f;  // show only the upper sheet of the hyperboloid;

    float y_max = +2.f;


    for (int idx_y_axis = 1; idx_y_axis < limit_y_axis; idx_y_axis++)
    {
        float height_y = y_min +  1.f * idx_y_axis * (y_max - y_min) / (float)limit_y_axis;

        float rho = sqrt(
            //  height_y * height_y - 0.04f

            height_y * height_y - y_min * y_min
        );


        for (UINT idx_theta = 0; idx_theta < limit_theta; idx_theta++)
        {
            float angle_theta = idx_theta * XM_2PI / (float)limit_theta;


            //   Project down onto the x-z plane: 

            float r_x = rho * cosf(angle_theta); 
            float r_z = rho * sinf(angle_theta); 

            // float k_a = 1.f; 
            float k_a = 0.5f; 

            XMFLOAT3 pt_on_hyperboloid = { r_x, height_y - k_a, r_z };

            current_instance.inst_pos = pt_on_hyperboloid;
            current_instance.inst_attributes.x = 100 * rho;
            current_instance.inst_attributes.y = +2.f;  // doesn't matter: too much other code in pixel shader...
            p_vect_Instances->push_back(current_instance);


            pt_on_hyperboloid = { r_x, k_a - height_y, r_z };
            current_instance.inst_pos = pt_on_hyperboloid;
            p_vect_Instances->push_back(current_instance);



#if 3 == 4
            float hemi_height = -1.f / height_y; 
            hemi_height /= 3.f; 
            hemi_height += 0.5f;
            XMFLOAT3 pt_lower_hemisphere =
            {
                r_x / height_y,   hemi_height,  r_z / height_y
            };
            current_instance.inst_pos = pt_lower_hemisphere;
            current_instance.inst_attributes.x = -rho;
            current_instance.inst_attributes.y = -2.f;  // doesn't matter: too much other code in pixel shader...
            p_vect_Instances->push_back(current_instance);
#endif 


            float d_x = r_x / (1.f + height_y);
            float d_z = r_z / (1.f + height_y);

            float radial_scale = 0.8f; 
            d_x *= radial_scale;
            d_z *= radial_scale;

            XMFLOAT3 pt_poincare = {
                d_x,
                d_z - 0.001f, 
                0.01f
            }; 
            current_instance.inst_pos = pt_poincare;
            current_instance.inst_attributes.x = -rho;
            current_instance.inst_attributes.y = -2.f;  // doesn't matter: too much other code in pixel shader...
            p_vect_Instances->push_back(current_instance);



        }
    }
    UINT card_instance_cubes = (uint32_t)p_vect_Instances->size();
    return card_instance_cubes;
}














void Hvy3DScene::gv_mesh_for_point()
{
    std::vector<VHG_Vertex_PosTex> vertex_vector = 
    {
        { XMFLOAT3(0.f, 0.f, 0.f), XMFLOAT2(1.f, 0.00f) }
    };

    m_vertexCount = (uint32)vertex_vector.size();

    size_t a_required_allocation = sizeof(VHG_Vertex_PosTex) * m_vertexCount;


    D3D11_SUBRESOURCE_DATA vertexBufferData = { 0 };
    ZeroMemory(&vertexBufferData, sizeof(vertexBufferData));
    vertexBufferData.pSysMem = &(vertex_vector[0]);
    vertexBufferData.SysMemPitch = 0;
    vertexBufferData.SysMemSlicePitch = 0;


    CD3D11_BUFFER_DESC vertexBufferDesc(
        (UINT)a_required_allocation,  
        D3D11_BIND_VERTEX_BUFFER
    );

    DX::ThrowIfFailed( m_deviceResources->GetD3DDevice()->CreateBuffer(
            &vertexBufferDesc, &vertexBufferData, &m_vertexBuffer
    ));


    // 
    //              setup the instance buffer  
    //  

    std::vector<VHG_Instance>           *ptr_vect_Instances = nullptr;

    ptr_vect_Instances = new std::vector<VHG_Instance>;


#ifdef GHV_OPTION_HYPERBOLOID
    m_instanceCount = gv_MeshHyperboloid(ptr_vect_Instances); 
#else
    m_instanceCount = gv_MeshMcMullenCusp(ptr_vect_Instances); 
#endif

    D3D11_SUBRESOURCE_DATA instanceBufferData = { 0 };

    ZeroMemory(&instanceBufferData, sizeof(instanceBufferData));

    instanceBufferData.pSysMem = &((*ptr_vect_Instances)[0]);
    instanceBufferData.SysMemPitch = 0;
    instanceBufferData.SysMemSlicePitch = 0;

    CD3D11_BUFFER_DESC instanceBufferDesc(m_instanceCount * sizeof(VHG_Instance), D3D11_BIND_VERTEX_BUFFER);

    DX::ThrowIfFailed( m_deviceResources->GetD3DDevice()->CreateBuffer(
            &instanceBufferDesc, &instanceBufferData, &m_instanceBuffer
    ));

    delete ptr_vect_Instances;
    ptr_vect_Instances = nullptr;

    //     Don't try this without the Index Buffer

    static const unsigned short cubeIndices[] =
    {
        0 
    };
    m_indexCount = ARRAYSIZE(cubeIndices);

    D3D11_SUBRESOURCE_DATA indexBufferData = { 0 };
    ZeroMemory(&indexBufferData, sizeof(indexBufferData));
    indexBufferData.pSysMem = cubeIndices;
    indexBufferData.SysMemPitch = 0;
    indexBufferData.SysMemSlicePitch = 0;

    CD3D11_BUFFER_DESC indexBufferDesc(sizeof(cubeIndices), D3D11_BIND_INDEX_BUFFER);

    DX::ThrowIfFailed( m_deviceResources->GetD3DDevice()->CreateBuffer(
            &indexBufferDesc, &indexBufferData, &m_indexBuffer
    ));
}
//  Closes Hvy3DScene::gv_mesh_for_point();  








void Hvy3DScene::gv_mesh_for_cube()
{
    assert((GHV_OPTION_COORD_CHIRALITY) == (GHV_OPTION_CHIRALITY_SINISTRAL));


    std::vector<VHG_Vertex_PosTex> vertex_vector = 
    {
        //  
        //     the +y face: 
        // 
        { XMFLOAT3(-1.0f, +1.0f, -1.0f), XMFLOAT2(1.f, 0.00f) },
        { XMFLOAT3(+1.0f, +1.0f, -1.0f), XMFLOAT2(0.f, 0.00f) },
        { XMFLOAT3(+1.0f, +1.0f, +1.0f), XMFLOAT2(0.f, 1.f) },
        { XMFLOAT3(-1.0f, +1.0f, +1.0f), XMFLOAT2(1.f, 1.f) },

        //  
        //     the -y face:  
        //  
        { XMFLOAT3(-1.0f, -1.0f, -1.0f), XMFLOAT2(0.f, 0.00f) },
        { XMFLOAT3(+1.0f, -1.0f, -1.0f), XMFLOAT2(1.0f, 0.00f) },
        { XMFLOAT3(+1.0f, -1.0f, +1.0f), XMFLOAT2(1.0f,  1.f) },
        { XMFLOAT3(-1.0f, -1.0f, +1.0f), XMFLOAT2(0.f, 1.f) },

        // 
        //    the  -x face: 
        //   
        { XMFLOAT3(-1.0f, -1.0f, +1.0f), XMFLOAT2(0.00f, 1.f) },
        { XMFLOAT3(-1.0f, -1.0f, -1.0f), XMFLOAT2(1.f,   1.f) },
        { XMFLOAT3(-1.0f, +1.0f, -1.0f), XMFLOAT2(1.f,   0.f) },
        { XMFLOAT3(-1.0f, +1.0f, +1.0f), XMFLOAT2(0.00f, 0.f) },

        // 
        //    the +x face: 
        //   
        { XMFLOAT3(+1.0f, -1.0f, +1.0f), XMFLOAT2(1.f,    1.f) },
        { XMFLOAT3(+1.0f, -1.0f, -1.0f), XMFLOAT2(0.00f,  1.f) },
        { XMFLOAT3(+1.0f, +1.0f, -1.0f), XMFLOAT2(0.00f,  0.00f) },
        { XMFLOAT3(+1.0f, +1.0f, +1.0f), XMFLOAT2(1.f,    0.00f) },

        //  
        //   the front face is the -z face: 
        //  
        { XMFLOAT3(-1.0f, -1.0f, -1.0f), XMFLOAT2(0.f,     1.f) },   //  16
        { XMFLOAT3(+1.0f, -1.0f, -1.0f), XMFLOAT2(1.00f,   1.f) },   //  17 
        { XMFLOAT3(+1.0f, +1.0f, -1.0f), XMFLOAT2(1.00f,   0.f) },   //  18 
        { XMFLOAT3(-1.0f, +1.0f, -1.0f), XMFLOAT2(0.f,     0.f) },   //  19  

        //  
        //      the back face is the +z face: 
        //  
        { XMFLOAT3(-1.0f, -1.0f, +1.0f), XMFLOAT2(1.f, 1.f) },
        { XMFLOAT3(+1.0f, -1.0f, +1.0f), XMFLOAT2(0.f, 1.f) },
        { XMFLOAT3(+1.0f, +1.0f, +1.0f), XMFLOAT2(0.f, 0.f) },
        { XMFLOAT3(-1.0f, +1.0f, +1.0f), XMFLOAT2(1.f, 0.f) }
    
    };


    //   
    //     Choosing good size for VHG_Scale...
    //   
    //  fail  VHG_Scale  gv_scaleObj(0.001f) is too small!!!!!! 
    //               

    VHG_Scale   gv_scaleObj(VHG::EineKleine::k_sprite_scale);
    gv_scaleObj.posApply(vertex_vector);



    m_vertexCount = (uint32)vertex_vector.size();

    size_t a_required_allocation = sizeof(VHG_Vertex_PosTex) * m_vertexCount;


    D3D11_SUBRESOURCE_DATA vertexBufferData = { 0 };
    ZeroMemory(&vertexBufferData, sizeof(vertexBufferData));
    vertexBufferData.pSysMem = &(vertex_vector[0]);
    vertexBufferData.SysMemPitch = 0;
    vertexBufferData.SysMemSlicePitch = 0;


    CD3D11_BUFFER_DESC vertexBufferDesc(
        (UINT)a_required_allocation,  
        D3D11_BIND_VERTEX_BUFFER
    );

    DX::ThrowIfFailed(
        m_deviceResources->GetD3DDevice()->CreateBuffer(
            &vertexBufferDesc,
            &vertexBufferData,
            &m_vertexBuffer
        ));


    // 
    //              setup the instance buffer  
    //  

    std::vector<VHG_Instance>           *ptr_vect_Instances = nullptr;

    ptr_vect_Instances = new std::vector<VHG_Instance>;

#ifdef GHV_OPTION_HYPERBOLOID
    m_instanceCount = gv_MeshHyperboloid(ptr_vect_Instances); 
#else
    m_instanceCount = gv_MeshMcMullenCusp(ptr_vect_Instances); 
#endif


    D3D11_SUBRESOURCE_DATA instanceBufferData = { 0 };

    ZeroMemory(&instanceBufferData, sizeof(instanceBufferData));

    instanceBufferData.pSysMem = &((*ptr_vect_Instances)[0]);
    instanceBufferData.SysMemPitch = 0;
    instanceBufferData.SysMemSlicePitch = 0;

    CD3D11_BUFFER_DESC instanceBufferDesc(m_instanceCount * sizeof(VHG_Instance), D3D11_BIND_VERTEX_BUFFER);

    DX::ThrowIfFailed(
        m_deviceResources->GetD3DDevice()->CreateBuffer(
            &instanceBufferDesc, &instanceBufferData, &m_instanceBuffer));

    delete ptr_vect_Instances;
    ptr_vect_Instances = nullptr;


    //   
    //     Don't try this without the Index Buffer
    // 

    static const unsigned short cubeIndices[] =
    {
        3,1,0,  		2,1,3,
        6,4,5,  		7,4,6,
        11,9,8,  		10,9,11,
        14,12,13,  		15,12,14,
        19,17,16,  		18,17,19,
        22,20,21,  		23,20,22
    };

    m_indexCount = ARRAYSIZE(cubeIndices);


    D3D11_SUBRESOURCE_DATA indexBufferData = { 0 };
    ZeroMemory(&indexBufferData, sizeof(indexBufferData));
    indexBufferData.pSysMem = cubeIndices;
    indexBufferData.SysMemPitch = 0;
    indexBufferData.SysMemSlicePitch = 0;

    CD3D11_BUFFER_DESC indexBufferDesc(sizeof(cubeIndices), D3D11_BIND_INDEX_BUFFER);

    DX::ThrowIfFailed(
        m_deviceResources->GetD3DDevice()->CreateBuffer(
            &indexBufferDesc, &indexBufferData, &m_indexBuffer));
}




void Hvy3DScene::CreateDeviceDependentResources()
{
    e_primitive = DirectX::GeometricPrimitive::CreateGeoSphere( 
        m_deviceResources->GetD3DDeviceContext(), 
        2.00f,   //  radius originally 1.9f; 
        3,      //  tessellation factor, e.g. 3 for GeoSphere, but 7 for u-v Sphere; 
        false 
    );

    DirectX::CreateWICTextureFromFile(
        m_deviceResources->GetD3DDevice(), 
        L"Assets\\afmobius__650_x_650.png", 
        nullptr, 
        e_texture_srv_1.ReleaseAndGetAddressOf(), 
        0
    );

    D3D11_SAMPLER_DESC sampDesc;
    ZeroMemory(&sampDesc, sizeof(sampDesc));
    sampDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_POINT;
    sampDesc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;
    sampDesc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;
    sampDesc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;
    sampDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;
    sampDesc.MinLOD = 0;
    sampDesc.MaxLOD = D3D11_FLOAT32_MAX;

    DX::ThrowIfFailed(
        m_deviceResources->GetD3DDevice()->CreateSamplerState(
            &sampDesc, e_texture_sampler_state.ReleaseAndGetAddressOf()));

	// Load shaders asynchronously.

    auto loadVSTask = DX::ReadDataAsync(L"ghv_Instancing_VertexShader.cso");
    auto loadPSTask = DX::ReadDataAsync(L"ghv_Instancing_PixelShader.cso");

	// After the vertex shader file is loaded, create the shader and input layout.
	auto createVSTask = loadVSTask.then([this](const std::vector<byte>& fileData) {
		DX::ThrowIfFailed(
			m_deviceResources->GetD3DDevice()->CreateVertexShader(
				&fileData[0],
				fileData.size(),
				nullptr,
				&m_vertexShader
				)
			);


        static const D3D11_INPUT_ELEMENT_DESC vertexDesc[] =
        {
            { "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,    D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA,   0 },
            { "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT,    0,    D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA,   0 },
            { "TEXCOORD", 1, DXGI_FORMAT_R32G32B32_FLOAT, 1,    D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_INSTANCE_DATA, 1 },
            { "TEXCOORD", 2, DXGI_FORMAT_R32G32B32_FLOAT, 1,    D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_INSTANCE_DATA, 1 }
        };


		DX::ThrowIfFailed(
			m_deviceResources->GetD3DDevice()->CreateInputLayout(
				vertexDesc,
				ARRAYSIZE(vertexDesc),
				&fileData[0],
				fileData.size(),
				&m_inputLayout
				)
			);
	});












	// After the pixel shader file is loaded, create the shader and constant buffer.
	auto createPSTask = loadPSTask.then([this](const std::vector<byte>& fileData) {
		DX::ThrowIfFailed(
			m_deviceResources->GetD3DDevice()->CreatePixelShader(
				&fileData[0],
				fileData.size(),
				nullptr,
				&m_pixelShader
				)
			);

		CD3D11_BUFFER_DESC constantBufferDesc(sizeof(ModelViewProjectionConstantBuffer) , D3D11_BIND_CONSTANT_BUFFER);
		DX::ThrowIfFailed(
			m_deviceResources->GetD3DDevice()->CreateBuffer(
				&constantBufferDesc,
				nullptr,
				&m_constantBuffer
				)
			);
	});






	// Once both shaders are loaded, create the mesh.
	auto createCubeTask = (createPSTask && createVSTask).then([this] () {

#ifdef GHV_OPTION_MESH_POINT
        gv_mesh_for_point(); 
#else
        gv_mesh_for_cube(); 
#endif

	});






	// Once the cube is loaded, the object is ready to be rendered.

    createCubeTask.then([this] () {
		m_loadingComplete = true;
	});
}









void Hvy3DScene::ReleaseDeviceDependentResources()
{
	m_loadingComplete = false;
	m_vertexShader.Reset();
	m_inputLayout.Reset();
	m_pixelShader.Reset();
	m_constantBuffer.Reset();
	m_vertexBuffer.Reset();
	m_indexBuffer.Reset();
}
